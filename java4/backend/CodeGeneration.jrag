/* Copyright (c) 2005-2008, Torbjorn Ekman
 *                    2016, Jesper Ã–qvist <jesper.oqvist@cs.lth.se>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

aspect CodeGeneration {

  protected int ASTNode.bcStartIndex = -1;

  protected int ASTNode.bcEndIndex = -1;

  public int ASTNode.getBcStartIndex(){
  	return this.bcStartIndex;
  }

  public int ASTNode.getBcEndIndex(){
  	return this.bcEndIndex;
  }


  public void ASTNode.setSourceLineNumber(int i) {
    setStart(ASTNode.makePosition(i, 1));
  }

  syn int ASTNode.sourceLineNumber() = getStart() != 0 ? getLine(getStart()) : -1;

  eq ReturnStmt.sourceLineNumber() {
    int num = super.sourceLineNumber();
    if (num != -1) {
      return num;
    }
    if (hasResult()) {
      num = getResult().findFirstSourceLineNumber();
      if (num != -1) {
        return num;
      }
    }
    return getLine(getParent().getParent().getEnd());
  }

  eq ExprStmt.sourceLineNumber() = getExpr().findFirstSourceLineNumber();

  eq Access.sourceLineNumber() = findFirstSourceLineNumber();

  protected int ASTNode.findFirstSourceLineNumber() {
    if (getStart() != 0) {
      return getLine(getStart());
    }
    for (int i = 0; i < getNumChild(); i++) {
      int num = getChild(i).findFirstSourceLineNumber();
      if (num != -1) {
        return num;
      }
    }
    return -1;
  }

  inh int VariableDeclarator.variableScopeEndLabel(CodeGeneration gen);

  syn lazy int Block.variableScopeEndLabel(CodeGeneration gen) = gen.variableScopeLabel();

  eq Block.getStmt(int i).variableScopeEndLabel(CodeGeneration gen) = variableScopeEndLabel(gen);

  syn lazy int ForStmt.variableScopeEndLabel(CodeGeneration gen) = gen.variableScopeLabel();

  eq ForStmt.getInitStmt(int i).variableScopeEndLabel(CodeGeneration gen) =
      variableScopeEndLabel(gen);

  eq Program.getChild(int i).variableScopeEndLabel(CodeGeneration gen) {
    throw new Error("variableScopeEndLabel not valid from here");
  }

  /** Push a constant value. */
  public static void IntegerLiteral.push(ASTNode<ASTNode> node, CodeGeneration gen, int value) {
    switch(value) {
      case -1:
        gen.emit(node, Bytecode.ICONST_M1);
        break;
      case 0:
        gen.emit(node, Bytecode.ICONST_0);
        break;
      case 1:
        gen.emit(node, Bytecode.ICONST_1);
        break;
      case 2:
        gen.emit(node, Bytecode.ICONST_2);
        break;
      case 3:
        gen.emit(node, Bytecode.ICONST_3);
        break;
      case 4:
        gen.emit(node, Bytecode.ICONST_4);
        break;
      case 5:
        gen.emit(node, Bytecode.ICONST_5);
        break;
      default:
        if (value >= -128 && value <= 127) {
          gen.emit(node, Bytecode.BIPUSH).add(value);
        } else if (value >= -32768 && value <= 32767) {
          gen.emit(node, Bytecode.SIPUSH).add2(value);
        } else {
          int index = gen.constantPool().addConstant(value);
          if (index < 256) {
            gen.emit(node, Bytecode.LDC).add(index);
          } else {
            gen.emit(node, Bytecode.LDC_W).add2(index);
          }
        }
    }
  }

  public static void LongLiteral.push(ASTNode<ASTNode> node, CodeGeneration gen, long value) {
    if (value == 0) {
      gen.emit(node, Bytecode.LCONST_0);
    } else if (value == 1) {
      gen.emit(node, Bytecode.LCONST_1);
    } else {
      int index = gen.constantPool().addConstant(value);
      gen.emit(node, Bytecode.LDC2_W).add2(index);
    }
  }

  public static void DoubleLiteral.push(ASTNode<ASTNode> node, CodeGeneration gen, double value) {
    if (value == 0) {
      gen.emit(node, Bytecode.DCONST_0);
    } else if (value == 1) {
      gen.emit(node, Bytecode.DCONST_1);
    } else {
      int index = gen.constantPool().addConstant(value);
      gen.emit(node, Bytecode.LDC2_W).add2(index);
    }
  }

  public static void FloatingPointLiteral.push(ASTNode<ASTNode> node, CodeGeneration gen, float value) {
    if (value == 0) {
      gen.emit(node, Bytecode.FCONST_0);
    } else if (value == 1) {
      gen.emit(node, Bytecode.FCONST_1);
    } else if (value == 2) {
      gen.emit(node, Bytecode.FCONST_2);
    } else {
      int index = gen.constantPool().addConstant(value);
      if (index < 256) {
        gen.emit(node, Bytecode.LDC).add(index);
      } else {
        gen.emit(node, Bytecode.LDC_W).add2(index);
      }
    }
  }

  public static void StringLiteral.push(ASTNode<ASTNode> node, CodeGeneration gen, String value) {
    int index = gen.constantPool().addConstant(value);
    if (index < 256) {
      gen.emit(node, Bytecode.LDC).add(index);
    } else {
      gen.emit(node, Bytecode.LDC_W).add2(index);
    }
  }

  public static void BooleanLiteral.push(ASTNode<ASTNode> node, CodeGeneration gen, boolean value) {
    gen.emit(node, value ? Bytecode.ICONST_1 : Bytecode.ICONST_0);
  }

  public void TypeDecl.emitPushConstant(ASTNode<ASTNode> node, CodeGeneration gen, int value) {
  }

  public void IntegralType.emitPushConstant(ASTNode<ASTNode> node, CodeGeneration gen, int value) {
    IntegerLiteral.push(node, gen, value);
  }

  public void LongType.emitPushConstant(ASTNode<ASTNode> node, CodeGeneration gen, int value) {
    LongLiteral.push(node, gen, value);
  }

  public void DoubleType.emitPushConstant(ASTNode<ASTNode> node, CodeGeneration gen, int value) {
    DoubleLiteral.push(node, gen, value);
  }

  public void FloatType.emitPushConstant(ASTNode<ASTNode> node, CodeGeneration gen, int value) {
    FloatingPointLiteral.push(node, gen, value);
  }

  public void Literal.emitPushConstant(CodeGeneration gen) {
    System.err.println("ERROR: Tried to generate bytecode for: " + getClass().getName());
  }

  public void IntegerLiteral.emitPushConstant(CodeGeneration gen) {
    type().emitPushConstant(this, gen, constant().intValue());
  }

  public void CharacterLiteral.emitPushConstant(CodeGeneration gen) {
    type().emitPushConstant(this, gen, constant().intValue());
  }

  public void FloatingPointLiteral.emitPushConstant(CodeGeneration gen) {
    FloatingPointLiteral.push(this, gen, constant().floatValue());
  }

  public void LongLiteral.emitPushConstant(CodeGeneration gen) {
    LongLiteral.push(this, gen, constant().longValue());
  }

  public void DoubleLiteral.emitPushConstant(CodeGeneration gen) {
    DoubleLiteral.push(this, gen, constant().doubleValue());
  }

  public void StringLiteral.emitPushConstant(CodeGeneration gen) {
    StringLiteral.push(this, gen, getLITERAL());
  }

  public void NullLiteral.emitPushConstant(CodeGeneration gen) {
    gen.emit(this, Bytecode.ACONST_NULL);
  }

  public void BooleanLiteral.emitPushConstant(CodeGeneration gen) {
    BooleanLiteral.push(this, gen, constant().booleanValue());
  }

  public void ASTNode.error() {
    Throwable t = new Throwable();
    StackTraceElement[] ste = new Throwable().getStackTrace();
    String s = ste[1].toString();
    throw new Error(s+" Cannot create bytecode for:"+getClass().getName());
  }

  public void Constant.createBCode(ASTNode<ASTNode> node, CodeGeneration gen) {
    if (this instanceof ConstantInt) {
      IntegerLiteral.push(node, gen, intValue());
    } else if (this instanceof ConstantLong) {
      LongLiteral.push(node, gen, longValue());
    } else if (this instanceof ConstantFloat) {
      FloatingPointLiteral.push(node, gen, floatValue());
    } else if (this instanceof ConstantDouble) {
      DoubleLiteral.push(node, gen, doubleValue());
    } else if (this instanceof ConstantChar) {
      IntegerLiteral.push(node, gen, intValue());
    } else if (this instanceof ConstantBoolean) {
      BooleanLiteral.push(node, gen, booleanValue());
    } else if (this instanceof ConstantString) {
      StringLiteral.push(node, gen, stringValue());
    }
  }

  public void TypeDecl.emitReturn(ASTNode<ASTNode> node, CodeGeneration gen) {
    error();
  }

  public void VoidType.emitReturn(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.RETURN);
  }

  public void PrimitiveType.emitReturn(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.IRETURN);
  }

  public void LongType.emitReturn(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.LRETURN);
  }

  public void FloatType.emitReturn(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.FRETURN);
  }

  public void DoubleType.emitReturn(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.DRETURN);
  }

  public void ReferenceType.emitReturn(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.ARETURN);
  }

  public void NullType.emitReturn(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.ARETURN);
  }

  syn byte TypeDecl.arrayLoad() {
    throw new Error("Cannot create array load for TypeDecl");
  }

  eq ReferenceType.arrayLoad() = Bytecode.AALOAD;

  eq IntType.arrayLoad() = Bytecode.IALOAD;

  eq LongType.arrayLoad() = Bytecode.LALOAD;

  eq FloatType.arrayLoad() = Bytecode.FALOAD;

  eq DoubleType.arrayLoad() = Bytecode.DALOAD;

  eq ByteType.arrayLoad() = Bytecode.BALOAD;

  eq CharType.arrayLoad() = Bytecode.CALOAD;

  eq ShortType.arrayLoad() = Bytecode.SALOAD;

  eq BooleanType.arrayLoad() = Bytecode.BALOAD;

  public void TypeDecl.emitLoadLocal(ASTNode<ASTNode> node, CodeGeneration gen, int pos) {
    error();
  }

  public void PrimitiveType.emitLoadLocal(ASTNode<ASTNode> node, CodeGeneration gen, int pos) {
    gen.maxLocals = Math.max(gen.maxLocals, pos+1);
    if (pos == 0) {
      gen.emit(node, Bytecode.ILOAD_0);
    } else if (pos == 1) {
      gen.emit(node, Bytecode.ILOAD_1);
    } else if (pos == 2) {
      gen.emit(node, Bytecode.ILOAD_2);
    } else if (pos == 3) {
      gen.emit(node, Bytecode.ILOAD_3);
    } else if (pos < 256) {
      gen.emit(node, Bytecode.ILOAD).add(pos);
    } else {
      gen.emit(node, Bytecode.WIDE).emit(node, Bytecode.ILOAD).add2(pos);
    }
  }

  public void LongType.emitLoadLocal(ASTNode<ASTNode> node, CodeGeneration gen, int pos) {
    gen.maxLocals = Math.max(gen.maxLocals, pos+2);
    if (pos == 0) {
      gen.emit(node, Bytecode.LLOAD_0);
    } else if (pos == 1) {
      gen.emit(node, Bytecode.LLOAD_1);
    } else if (pos == 2) {
      gen.emit(node, Bytecode.LLOAD_2);
    } else if (pos == 3) {
      gen.emit(node, Bytecode.LLOAD_3);
    } else if (pos < 256) {
      gen.emit(node, Bytecode.LLOAD).add(pos);
    } else {
      gen.emit(node, Bytecode.WIDE).emit(node, Bytecode.LLOAD).add2(pos);
    }
  }

  public void FloatType.emitLoadLocal(ASTNode<ASTNode> node, CodeGeneration gen, int pos) {
    gen.maxLocals = Math.max(gen.maxLocals, pos+1);
    if (pos == 0) {
      gen.emit(node, Bytecode.FLOAD_0);
    } else if (pos == 1) {
      gen.emit(node, Bytecode.FLOAD_1);
    } else if (pos == 2) {
      gen.emit(node, Bytecode.FLOAD_2);
    } else if (pos == 3) {
      gen.emit(node, Bytecode.FLOAD_3);
    } else if (pos < 256) {
      gen.emit(node, Bytecode.FLOAD).add(pos);
    } else {
      gen.emit(node, Bytecode.WIDE).emit(node, Bytecode.FLOAD).add2(pos);
    }
  }

  public void DoubleType.emitLoadLocal(ASTNode<ASTNode> node, CodeGeneration gen, int pos) {
    gen.maxLocals = Math.max(gen.maxLocals, pos+2);
    if (pos == 0) {
      gen.emit(node, Bytecode.DLOAD_0);
    } else if (pos == 1) {
      gen.emit(node, Bytecode.DLOAD_1);
    } else if (pos == 2) {
      gen.emit(node, Bytecode.DLOAD_2);
    } else if (pos == 3) {
      gen.emit(node, Bytecode.DLOAD_3);
    } else if (pos < 256) {
      gen.emit(node, Bytecode.DLOAD).add(pos);
    } else {
      gen.emit(node, Bytecode.WIDE).emit(node, Bytecode.DLOAD).add2(pos);
    }
  }

  public void ReferenceType.emitLoadLocal(ASTNode<ASTNode> node, CodeGeneration gen, int pos) {
    gen.emitLoadReference(node, pos);
  }

  public void NullType.emitLoadLocal(ASTNode<ASTNode> node, CodeGeneration gen, int pos) {
    gen.emitLoadReference(node, pos);
  }

  /** Generate bytecode to load this field. */
  protected static void ASTNode.emitLoadField(ASTNode<ASTNode> node, CodeGeneration gen, Variable field,
      TypeDecl hostType) {
    if (field.hostType().isArrayDecl() && field.name().equals("length")) {
      gen.emit(node, Bytecode.ARRAYLENGTH);
      return;
    }
    String classname = hostType.constantPoolName();
    String desc = field.type().typeDescriptor();
    String name = field.name();
    int index = gen.constantPool().addFieldref(classname, name, desc);
    if (field.isStatic()) {
      gen.emit(node, Bytecode.GETSTATIC, field.type().variableSize()).add2(index);
    } else {
      gen.emit(node, Bytecode.GETFIELD, field.type().variableSize() - 1).add2(index);
    }
  }

  public void Expr.emitStore(ASTNode<ASTNode> node, CodeGeneration gen) {
    error("emitStore called with " + getClass().getName());
  }

  public void AbstractDot.emitStore(ASTNode<ASTNode> node, CodeGeneration gen) {
    lastAccess().emitStore(node, gen);
  }

  public void VarAccess.emitStore(ASTNode<ASTNode> node, CodeGeneration gen) {
    Variable v = decl();
    if (v instanceof VariableDeclarator) {
      VariableDeclarator var = (VariableDeclarator) v;
      if (unassignedBefore(v)) {
         gen.addLocalVariableEntryAtCurrentPC(var.name(), var.type().typeDescriptor(),
             var.localNum(), var.variableScopeEndLabel(gen));
      }
      var.type().emitStoreLocal(node, gen, var.localNum());
    } else if (v.isField()) {
      if (v.isPrivate() && !hostType().hasField(v.name())) {
        fieldWriteAccessor(v, fieldQualifierType())
            .emitInvokeMethod(node, gen, fieldQualifierType());
      } else {
        emitStoreField(node, gen, v, fieldQualifierType());
      }
    } else if (v instanceof ParameterDeclaration) {
      ParameterDeclaration decl = (ParameterDeclaration) v;
      decl.type().emitStoreLocal(node, gen, decl.localNum());
    }
  }

  public void ArrayAccess.emitStore(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, type().arrayStore());
  }

  syn byte TypeDecl.arrayStore() {
    throw new Error("Cannot create array load for TypeDecl");
  }

  eq ReferenceType.arrayStore() = Bytecode.AASTORE;

  eq IntType.arrayStore() = Bytecode.IASTORE;

  eq LongType.arrayStore() = Bytecode.LASTORE;

  eq FloatType.arrayStore() = Bytecode.FASTORE;

  eq DoubleType.arrayStore() = Bytecode.DASTORE;

  eq ByteType.arrayStore() = Bytecode.BASTORE;

  eq CharType.arrayStore() = Bytecode.CASTORE;

  eq ShortType.arrayStore() = Bytecode.SASTORE;

  eq BooleanType.arrayStore() = Bytecode.BASTORE;

  /** Generate bytecode to store a field in the given hostType. */
  protected void ASTNode.emitStoreField(ASTNode<ASTNode> node, CodeGeneration gen, Variable var, TypeDecl hostType) {
    String classname = hostType.constantPoolName();
    String desc = var.type().typeDescriptor();
    String name = var.name();
    int index = gen.constantPool().addFieldref(classname, name, desc);
    if (var.isStatic()) {
      gen.emit(node, Bytecode.PUTSTATIC, -var.type().variableSize()).add2(index);
    } else {
      gen.emit(node, Bytecode.PUTFIELD, -var.type().variableSize() - 1).add2(index);
    }
  }

  public void TypeDecl.emitStoreLocal(ASTNode<ASTNode> node, CodeGeneration gen, int pos) {
    error();
  }

  public void PrimitiveType.emitStoreLocal(ASTNode<ASTNode> node, CodeGeneration gen, int pos) {
    gen.maxLocals = Math.max(gen.maxLocals, pos+1);
    if (pos == 0) {
      gen.emit(node, Bytecode.ISTORE_0);
    } else if (pos == 1) {
      gen.emit(node, Bytecode.ISTORE_1);
    } else if (pos == 2) {
      gen.emit(node, Bytecode.ISTORE_2);
    } else if (pos == 3) {
      gen.emit(node, Bytecode.ISTORE_3);
    } else if (pos < 256) {
      gen.emit(node, Bytecode.ISTORE).add(pos);
    } else {
      gen.emit(node, Bytecode.WIDE).emit(node, Bytecode.ISTORE).add2(pos);
    }
  }

  public void LongType.emitStoreLocal(ASTNode<ASTNode> node, CodeGeneration gen, int pos) {
    gen.maxLocals = Math.max(gen.maxLocals, pos+2);
    if (pos == 0) {
      gen.emit(node, Bytecode.LSTORE_0);
    } else if (pos == 1) {
      gen.emit(node, Bytecode.LSTORE_1);
    } else if (pos == 2) {
      gen.emit(node, Bytecode.LSTORE_2);
    } else if (pos == 3) {
      gen.emit(node, Bytecode.LSTORE_3);
    } else if (pos < 256) {
      gen.emit(node, Bytecode.LSTORE).add(pos);
    } else {
      gen.emit(node, Bytecode.WIDE).emit(node, Bytecode.LSTORE).add2(pos);
    }
  }

  public void FloatType.emitStoreLocal(ASTNode<ASTNode> node, CodeGeneration gen, int pos) {
    gen.maxLocals = Math.max(gen.maxLocals, pos+1);
    if (pos == 0) {
      gen.emit(node, Bytecode.FSTORE_0);
    } else if (pos == 1) {
      gen.emit(node, Bytecode.FSTORE_1);
    } else if (pos == 2) {
      gen.emit(node, Bytecode.FSTORE_2);
    } else if (pos == 3) {
      gen.emit(node, Bytecode.FSTORE_3);
    } else if (pos < 256) {
      gen.emit(node, Bytecode.FSTORE).add(pos);
    } else {
      gen.emit(node, Bytecode.WIDE).emit(node, Bytecode.FSTORE).add2(pos);
    }
  }

  public void DoubleType.emitStoreLocal(ASTNode<ASTNode> node, CodeGeneration gen, int pos) {
    gen.maxLocals = Math.max(gen.maxLocals, pos+2);
    if (pos == 0) {
      gen.emit(node, Bytecode.DSTORE_0);
    } else if (pos == 1) {
      gen.emit(node, Bytecode.DSTORE_1);
    } else if (pos == 2) {
      gen.emit(node, Bytecode.DSTORE_2);
    } else if (pos == 3) {
      gen.emit(node, Bytecode.DSTORE_3);
    } else if (pos < 256) {
      gen.emit(node, Bytecode.DSTORE).add(pos);
    } else {
      gen.emit(node, Bytecode.WIDE).emit(node, Bytecode.DSTORE).add2(pos);
    }
  }

  public void ReferenceType.emitStoreLocal(ASTNode<ASTNode> node, CodeGeneration gen, int pos) {
    gen.emitStoreReference(node, pos);
  }

  public void NullType.emitStoreLocal(ASTNode<ASTNode> node, CodeGeneration gen, int pos) {
    gen.emitStoreReference(node, pos);
  }

  inh TypeDecl TryStmt.typeThrowable();

  public void TypeDecl.emitDup(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.DUP);
  }

  public void VoidType.emitDup(ASTNode<ASTNode> node, CodeGeneration gen) {
  }

  public void DoubleType.emitDup(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.DUP2);
  }

  public void LongType.emitDup(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.DUP2);
  }

  public void TypeDecl.emitDup_x1(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.DUP_X1);
  }

  public void VoidType.emitDup_x1(ASTNode<ASTNode> node, CodeGeneration gen) {
  }

  public void DoubleType.emitDup_x1(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.DUP2_X1);
  }

  public void LongType.emitDup_x1(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.DUP2_X1);
  }

  public void TypeDecl.emitDup_x2(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.DUP_X2);
  }

  public void VoidType.emitDup_x2(ASTNode<ASTNode> node, CodeGeneration gen) {
  }

  public void DoubleType.emitDup_x2(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.DUP2_X2);
  }

  public void LongType.emitDup_x2(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.DUP2_X2);
  }

  public void TypeDecl.emitPop(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.POP);
  }

  public void VoidType.emitPop(ASTNode<ASTNode> node, CodeGeneration gen) {
  }

  public void DoubleType.emitPop(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.POP2);
  }

  public void LongType.emitPop(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.POP2);
  }

  public void MethodDecl.emitInvokeMethod(ASTNode<ASTNode> node, CodeGeneration gen, TypeDecl hostType) {
    if (hostType.isInterfaceDecl()) {
      String classname = hostType.constantPoolName();
      String desc = descName();
      String name = name();
      int index = gen.constantPool().addInterfaceMethodref(classname, name, desc);
      int numArg = 1;
      for (int i = 0; i < getNumParameter(); i++) {
        numArg += getParameter(i).type().variableSize();
      }
      int stackChange = type().variableSize() - numArg;
      gen.emit(node, Bytecode.INVOKEINTERFACE, stackChange)
            .add2(index).add(numArg).add(0);
    } else {
      String classname = hostType.constantPoolName();
      String desc = descName();
      String name = name();
      int index = gen.constantPool().addMethodref(classname, name, desc);
      int stackChange = type().variableSize();
      for (int i = 0; i < getNumParameter(); i++) {
          stackChange -= getParameter(i).type().variableSize();
      }
      if (isStatic()) {
        gen.emit(node, Bytecode.INVOKESTATIC, stackChange).add2(index);
      } else {
        stackChange -= 1;
        gen.emit(node, Bytecode.INVOKEVIRTUAL, stackChange).add2(index);
      }
    }
  }

  public void MethodDecl.emitInvokeSpecialMethod(ASTNode<ASTNode> node, CodeGeneration gen, TypeDecl hostType) {
    String classname = hostType.constantPoolName();
    String desc = descName();
    String name = name();
    int index = gen.constantPool().addMethodref(classname, name, desc);
    int stackChange = type().variableSize() - 1;
    for (int i = 0; i < getNumParameter(); i++) {
      stackChange -= getParameter(i).type().variableSize();
    }
    gen.emit(node, Bytecode.INVOKESPECIAL, stackChange).add2(index);
  }

  public void ConstructorDecl.emitInvokeConstructor(ASTNode<ASTNode> node, CodeGeneration gen) {
    int stackChange = -1;
    for (int i = 0; i < getNumParameter(); i++) {
      stackChange -= getParameter(i).type().variableSize();
    }
    for (Variable var : hostType().enclosingVariables()) {
      stackChange -= var.type().variableSize();
    }
    if (hostType().needsEnclosing()) {
      stackChange -= 1;
    }
    if (hostType().needsSuperEnclosing()) {
      stackChange -= 1;
    }
    String classname = hostType().constantPoolName();
    String desc = descName();
    String name = "<init>";
    int index = gen.constantPool().addMethodref(classname, name, desc);
    gen.emit(node, Bytecode.INVOKESPECIAL, stackChange).add2(index);
  }

  public void TypeDecl.emitNew(ASTNode<ASTNode> node, CodeGeneration gen) {
    int index = gen.constantPool().addClass(constantPoolName());
    gen.emit(node, Bytecode.NEW).add2(index);
  }
}

aspect CodeGenerationConversions {
  void TypeDecl.emitAssignConvTo(ASTNode<ASTNode> node, CodeGeneration gen, TypeDecl type) {
    if (!type.isIntegralType() || !isIntegralType() || type.isLong()) {
      emitCastTo(node, gen, type);
    }
  }

  void TypeDecl.emitCastTo(ASTNode<ASTNode> node, CodeGeneration gen, TypeDecl type) {
    throw new Error("CastTo not implemented for " + getClass().getName());
  }

  void ReferenceType.emitCastTo(ASTNode<ASTNode> node, CodeGeneration gen, TypeDecl type) {
    if (!instanceOf(type) && !type.isNull()) {
      gen.emitCheckCast(node, type);
    }
  }

  void IntType.emitCastTo(ASTNode<ASTNode> node, CodeGeneration gen, TypeDecl type) {
    type.intToThis(node, gen);
  }

  void FloatType.emitCastTo(ASTNode<ASTNode> node, CodeGeneration gen, TypeDecl type) {
    type.floatToThis(node, gen);
  }

  void DoubleType.emitCastTo(ASTNode<ASTNode> node, CodeGeneration gen, TypeDecl type) {
    type.doubleToThis(node, gen);
  }

  void LongType.emitCastTo(ASTNode<ASTNode> node, CodeGeneration gen, TypeDecl type) {
    type.longToThis(node, gen);
  }

  void ByteType.emitCastTo(ASTNode<ASTNode> node, CodeGeneration gen, TypeDecl type) {
    type.byteToThis(node, gen);
  }

  void ShortType.emitCastTo(ASTNode<ASTNode> node, CodeGeneration gen, TypeDecl type) {
    type.shortToThis(node, gen);
  }

  void CharType.emitCastTo(ASTNode<ASTNode> node, CodeGeneration gen, TypeDecl type) {
    type.charToThis(node, gen);
  }

  void BooleanType.emitCastTo(ASTNode<ASTNode> node, CodeGeneration gen, TypeDecl type) {
  }

  void NullType.emitCastTo(ASTNode<ASTNode> node, CodeGeneration gen, TypeDecl type) {
  }

  void TypeDecl.intToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    throw new Error("intToThis not implemented for " + getClass().getName());
  }

  void IntType.intToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
  }

  void LongType.intToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.I2L);
  }

  void FloatType.intToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.I2F);
  }

  void DoubleType.intToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.I2D);
  }

  void ByteType.intToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.I2B);
  }

  void CharType.intToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.I2C);
  }

  void ShortType.intToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.I2S);
  }

  void TypeDecl.floatToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    throw new Error("floatToThis not implemented for " + getClass().getName());
  }

  void IntType.floatToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.F2I);
  }

  void ByteType.floatToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.F2I).emit(node, Bytecode.I2B);
  }

  void ShortType.floatToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.F2I).emit(node, Bytecode.I2S);
  }

  void CharType.floatToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.F2I).emit(node, Bytecode.I2C);
  }

  void FloatType.floatToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
  }

  void LongType.floatToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.F2L);
  }

  void DoubleType.floatToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.F2D);
  }

  void TypeDecl.doubleToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    throw new Error("doubleToThis not implemented for " + getClass().getName());
  }

  void IntType.doubleToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.D2I);
  }

  void ByteType.doubleToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.D2I).emit(node, Bytecode.I2B);
  }

  void ShortType.doubleToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.D2I).emit(node, Bytecode.I2S);
  }

  void CharType.doubleToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.D2I).emit(node, Bytecode.I2C);
  }

  void FloatType.doubleToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.D2F);
  }

  void LongType.doubleToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.D2L);
  }

  void DoubleType.doubleToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
  }

  void TypeDecl.longToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    throw new Error("longToThis not implemented for " + getClass().getName());
  }

  void IntType.longToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.L2I);
  }

  void ByteType.longToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.L2I).emit(node, Bytecode.I2B);
  }

  void ShortType.longToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.L2I).emit(node, Bytecode.I2S);
  }

  void CharType.longToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.L2I).emit(node, Bytecode.I2C);
  }

  void FloatType.longToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.L2F);
  }

  void LongType.longToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
  }

  void DoubleType.longToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.L2D);
  }

  void TypeDecl.byteToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    throw new Error("byteToThis not implemented for " + getClass().getName());
  }

  void IntegralType.byteToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
  }

  void CharType.byteToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.I2C);
  }

  void FloatType.byteToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.I2F);
  }

  void LongType.byteToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.I2L);
  }

  void DoubleType.byteToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.I2D);
  }

  void TypeDecl.charToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    throw new Error("charToThis not implemented for " + getClass().getName());
  }

  void IntegralType.charToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
  }

  void ByteType.charToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.I2B);
  }

  void ShortType.charToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.I2S);
  }

  void FloatType.charToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.I2F);
  }

  void LongType.charToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.I2L);
  }

  void DoubleType.charToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.I2D);
  }

  void TypeDecl.shortToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    throw new Error("shortToThis not implemented for " + getClass().getName());
  }

  void IntegralType.shortToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
  }

  void ByteType.shortToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.I2B);
  }

  void CharType.shortToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.I2C);
  }

  void FloatType.shortToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.I2F);
  }

  void LongType.shortToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.I2L);
  }

  void DoubleType.shortToThis(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.I2D);
  }
}

aspect CodeGenerationBinaryOperations {
  void Expr.emitOperation(CodeGeneration gen) {
    error();
  }

  void MinusExpr.emitOperation(CodeGeneration gen) {
    type().neg(this, gen);
  }

  void PlusExpr.emitOperation(CodeGeneration gen) {
  }

  void BitNotExpr.emitOperation(CodeGeneration gen) {
    type().bitNot(this, gen);
  }

  void LogNotExpr.emitOperation(CodeGeneration gen) {
    type().logNot(this, gen);
  }

  void AddExpr.emitOperation(CodeGeneration gen) {
    type().add(this, gen);
  }

  void SubExpr.emitOperation(CodeGeneration gen) {
    type().sub(this, gen);
  }

  void MulExpr.emitOperation(CodeGeneration gen) {
    type().mul(this, gen);
  }

  void DivExpr.emitOperation(CodeGeneration gen) {
    type().div(this, gen);
  }

  void ModExpr.emitOperation(CodeGeneration gen) {
    type().rem(this, gen);
  }

  void LShiftExpr.emitOperation(CodeGeneration gen) {
    type().shl(this, gen);
  }

  void RShiftExpr.emitOperation(CodeGeneration gen) {
    type().shr(this, gen);
  }

  void URShiftExpr.emitOperation(CodeGeneration gen) {
    type().ushr(this, gen);
  }

  void OrBitwiseExpr.emitOperation(CodeGeneration gen) {
    type().bitor(this, gen);
  }

  void AndBitwiseExpr.emitOperation(CodeGeneration gen) {
    type().bitand(this, gen);
  }

  void XorBitwiseExpr.emitOperation(CodeGeneration gen) {
    type().bitxor(this, gen);
  }

  void TypeDecl.neg(ASTNode<ASTNode> node, CodeGeneration gen) {
    error();
  }

  void IntegralType.neg(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.INEG);
  }

  void LongType.neg(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.LNEG);
  }

  void FloatType.neg(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.FNEG);
  }

  void DoubleType.neg(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.DNEG);
  }

  void TypeDecl.bitNot(ASTNode<ASTNode> node, CodeGeneration gen) {
    error();
  }

  void IntegralType.bitNot(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.ICONST_M1).emit(node, Bytecode.IXOR);
  }

  void LongType.bitNot(ASTNode<ASTNode> node, CodeGeneration gen) {
    emitPushConstant(node, gen, -1); gen.emit(node, Bytecode.LXOR);
  }

  void TypeDecl.logNot(ASTNode<ASTNode> node, CodeGeneration gen) {
    error();
  }

  void BooleanType.logNot(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.ICONST_1).emit(node, Bytecode.IXOR);
  }

  void TypeDecl.add(ASTNode<ASTNode> node, CodeGeneration gen) {
    error();
  }

  void LongType.add(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.LADD);
  }

  void FloatType.add(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.FADD);
  }

  void DoubleType.add(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.DADD);
  }

  void IntegralType.add(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.IADD);
  }

  void TypeDecl.sub(ASTNode<ASTNode> node, CodeGeneration gen) {
    error();
  }

  void LongType.sub(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.LSUB);
  }

  void FloatType.sub(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.FSUB);
  }

  void DoubleType.sub(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.DSUB);
  }

  void IntegralType.sub(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.ISUB);
  }

  void TypeDecl.mul(ASTNode<ASTNode> node, CodeGeneration gen) {
    error();
  }

  void LongType.mul(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.LMUL);
  }

  void FloatType.mul(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.FMUL);
  }

  void DoubleType.mul(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.DMUL);
  }

  void IntegralType.mul(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.IMUL);
  }

  void TypeDecl.div(ASTNode<ASTNode> node, CodeGeneration gen) {
    error();
  }

  void LongType.div(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.LDIV);
  }

  void FloatType.div(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.FDIV);
  }

  void DoubleType.div(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.DDIV);
  }

  void IntegralType.div(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.IDIV);
  }

  void TypeDecl.rem(ASTNode<ASTNode> node, CodeGeneration gen) {
    error();
  }

  void LongType.rem(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.LREM);
  }

  void FloatType.rem(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.FREM);
  }

  void DoubleType.rem(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.DREM);
  }

  void IntegralType.rem(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.IREM);
  }

  void TypeDecl.shl(ASTNode<ASTNode> node, CodeGeneration gen) {
    error();
  }

  void LongType.shl(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.LSHL);
  }

  void IntegralType.shl(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.ISHL);
  }

  void TypeDecl.shr(ASTNode<ASTNode> node, CodeGeneration gen) {
    error();
  }

  void LongType.shr(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.LSHR);
  }

  void IntegralType.shr(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.ISHR);
  }

  void TypeDecl.ushr(ASTNode<ASTNode> node, CodeGeneration gen) {
    error();
  }

  void LongType.ushr(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.LUSHR);
  }

  void IntegralType.ushr(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.IUSHR);
  }

  void TypeDecl.bitand(ASTNode<ASTNode> node, CodeGeneration gen) {
    error();
  }

  void LongType.bitand(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.LAND);
  }

  void IntegralType.bitand(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.IAND);
  }

  void BooleanType.bitand(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.IAND);
  }

  void TypeDecl.bitor(ASTNode<ASTNode> node, CodeGeneration gen) {
    error();
  }

  void LongType.bitor(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.LOR);
  }

  void IntegralType.bitor(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.IOR);
  }

  void BooleanType.bitor(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.IOR);
  }

  void TypeDecl.bitxor(ASTNode<ASTNode> node, CodeGeneration gen) {
    error();
  }

  void LongType.bitxor(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.LXOR);
  }

  void IntegralType.bitxor(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.IXOR);
  }

  void BooleanType.bitxor(ASTNode<ASTNode> node, CodeGeneration gen) {
    gen.emit(node, Bytecode.IXOR);
  }
}

aspect CodeGenerationBranch {

  public void TypeDecl.branchLT(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    throw new Error("branchLT not supported for " + getClass().getName());
  }

  public void DoubleType.branchLT(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emit(node, Bytecode.DCMPG).emitCompare(node, Bytecode.IFLT, label);
  }

  public void FloatType.branchLT(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emit(node, Bytecode.FCMPG).emitCompare(node, Bytecode.IFLT, label);
  }

  public void LongType.branchLT(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emit(node, Bytecode.LCMP).emitCompare(node, Bytecode.IFLT, label);
  }


  public void IntegralType.branchLT(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emitCompare(node, Bytecode.IF_ICMPLT, label);
  }


  public void TypeDecl.branchLTInv(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    branchLT(node, gen, label);
  }

  public void DoubleType.branchLTInv(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emit(node, Bytecode.DCMPL).emitCompare(node, Bytecode.IFLT, label);
  }

  public void FloatType.branchLTInv(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emit(node, Bytecode.FCMPL).emitCompare(node, Bytecode.IFLT, label);
  }


  public void TypeDecl.branchLE(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    throw new Error("branchLE not supported for " + getClass().getName());
  }

  public void DoubleType.branchLE(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emit(node, Bytecode.DCMPG).emitCompare(node, Bytecode.IFLE, label);
  }

  public void FloatType.branchLE(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emit(node, Bytecode.FCMPG).emitCompare(node, Bytecode.IFLE, label);
  }

  public void LongType.branchLE(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emit(node, Bytecode.LCMP).emitCompare(node, Bytecode.IFLE, label);
  }



  public void IntegralType.branchLE(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emitCompare(node, Bytecode.IF_ICMPLE, label);
  }


  public void TypeDecl.branchLEInv(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    branchLE(node, gen, label);
  }

  public void DoubleType.branchLEInv(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emit(node, Bytecode.DCMPL).emitCompare(node, Bytecode.IFLE, label);
  }

  public void FloatType.branchLEInv(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emit(node, Bytecode.FCMPL).emitCompare(node, Bytecode.IFLE, label);
  }

  public void TypeDecl.branchGE(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    throw new Error("branchGE not supported for " + getClass().getName());
  }

  public void DoubleType.branchGE(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emit(node, Bytecode.DCMPL).emitCompare(node, Bytecode.IFGE, label);
  }

  public void FloatType.branchGE(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emit(node, Bytecode.FCMPL).emitCompare(node, Bytecode.IFGE, label);
  }

  public void LongType.branchGE(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emit(node, Bytecode.LCMP).emitCompare(node, Bytecode.IFGE, label);
  }

  public void IntegralType.branchGE(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emitCompare(node, Bytecode.IF_ICMPGE, label);
  }


  public void TypeDecl.branchGEInv(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    branchGE(node, gen, label);
  }

  public void DoubleType.branchGEInv(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emit(node, Bytecode.DCMPG).emitCompare(node, Bytecode.IFGE, label);
  }

  public void FloatType.branchGEInv(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emit(node, Bytecode.FCMPG).emitCompare(node, Bytecode.IFGE, label);
  }


  public void TypeDecl.branchGT(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    throw new Error("branchGT not supported for " + getClass().getName());
  }

  public void DoubleType.branchGT(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emit(node, Bytecode.DCMPL).emitCompare(node, Bytecode.IFGT, label);
  }

  public void FloatType.branchGT(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emit(node, Bytecode.FCMPL).emitCompare(node, Bytecode.IFGT, label);
  }

  public void LongType.branchGT(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emit(node, Bytecode.LCMP).emitCompare(node, Bytecode.IFGT, label);
  }

  public void IntegralType.branchGT(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emitCompare(node, Bytecode.IF_ICMPGT, label);
  }


  public void TypeDecl.branchGTInv(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    branchGT(node, gen, label);
  }

  public void DoubleType.branchGTInv(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emit(node, Bytecode.DCMPG).emitCompare(node, Bytecode.IFGT, label);
  }

  public void FloatType.branchGTInv(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emit(node, Bytecode.FCMPG).emitCompare(node, Bytecode.IFGT, label);
  }

  public void TypeDecl.branchEQ(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    throw new Error("branchEQ not supported for " + getClass().getName());
  }

  public void DoubleType.branchEQ(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emit(node, Bytecode.DCMPL).emitCompare(node, Bytecode.IFEQ, label);
  }

  public void FloatType.branchEQ(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emit(node, Bytecode.FCMPL).emitCompare(node, Bytecode.IFEQ, label);
  }

  public void LongType.branchEQ(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emit(node, Bytecode.LCMP).emitCompare(node, Bytecode.IFEQ, label);
  }

  public void IntegralType.branchEQ(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emitCompare(node, Bytecode.IF_ICMPEQ, label);
  }

  public void BooleanType.branchEQ(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emitCompare(node, Bytecode.IF_ICMPEQ, label);
  }

  public void ReferenceType.branchEQ(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emitCompare(node, Bytecode.IF_ACMPEQ, label);
  }

  public void NullType.branchEQ(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emitCompare(node, Bytecode.IF_ACMPEQ, label);
  }

  public void TypeDecl.branchNE(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    throw new Error("branchNE not supported for " + getClass().getName());
  }

  public void DoubleType.branchNE(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emit(node, Bytecode.DCMPL).emitCompare(node, Bytecode.IFNE, label);
  }

  public void FloatType.branchNE(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emit(node, Bytecode.FCMPL).emitCompare(node, Bytecode.IFNE, label);
  }

  public void LongType.branchNE(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emit(node, Bytecode.LCMP).emitCompare(node, Bytecode.IFNE, label);
  }

  public void IntegralType.branchNE(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emitCompare(node, Bytecode.IF_ICMPNE, label);
  }

  public void BooleanType.branchNE(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emitCompare(node, Bytecode.IF_ICMPNE, label);
  }

  public void ReferenceType.branchNE(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emitCompare(node, Bytecode.IF_ACMPNE, label);
  }

  public void NullType.branchNE(ASTNode<ASTNode> node, CodeGeneration gen, int label) {
    gen.emitCompare(node, Bytecode.IF_ACMPNE, label);
  }
}
